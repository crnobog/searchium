/* eslint-disable */
// @generated by protobuf-ts 2.9.0 with parameter output_legacy_commonjs,eslint_disable
// @generated from protobuf file "protobuf-net/bcl.proto" (package "bcl", syntax proto3)
// tslint:disable
//
// The types in here indicate how protobuf-net represents certain types when using protobuf-net specific
// library features. Note that it is not *required* to use any of these types, and cross-platform code
// should usually avoid them completely (ideally starting from a .proto schema)
//
//
// Some of these are ugly, sorry. The TimeSpan / DateTime dates here pre-date the introduction of Timestamp
// and Duration, and the "well known" types should be preferred when possible. Guids are particularly
// awkward - it turns out that there are multiple guid representations, and I accidentally used one that
// I can only call... "crazy-endian". Just make sure you check the order!
//
//
// It should not be necessary to use bcl.proto from code that uses protobuf-net
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message bcl.TimeSpan
 */
export interface TimeSpan {
    /**
     * @generated from protobuf field: sint64 value = 1;
     */
    value: bigint; // the size of the timespan (in units of the selected scale)    /**
     * @generated from protobuf field: bcl.TimeSpan.TimeSpanScale scale = 2;
     */
    scale: TimeSpan_TimeSpanScale; // the scale of the timespan [default = DAYS]}
/**
 * @generated from protobuf enum bcl.TimeSpan.TimeSpanScale
 */
export enum TimeSpan_TimeSpanScale {
    /**
     * @generated from protobuf enum value: DAYS = 0;
     */
    DAYS = 0,
    /**
     * @generated from protobuf enum value: HOURS = 1;
     */
    HOURS = 1,
    /**
     * @generated from protobuf enum value: MINUTES = 2;
     */
    MINUTES = 2,
    /**
     * @generated from protobuf enum value: SECONDS = 3;
     */
    SECONDS = 3,
    /**
     * @generated from protobuf enum value: MILLISECONDS = 4;
     */
    MILLISECONDS = 4,
    /**
     * @generated from protobuf enum value: TICKS = 5;
     */
    TICKS = 5,
    /**
     * dubious
     *
     * @generated from protobuf enum value: MINMAX = 15;
     */
    MINMAX = 15
}
/**
 * @generated from protobuf message bcl.DateTime
 */
export interface DateTime {
    /**
     * @generated from protobuf field: sint64 value = 1;
     */
    value: bigint; // the offset (in units of the selected scale) from 1970/01/01    /**
     * @generated from protobuf field: bcl.DateTime.TimeSpanScale scale = 2;
     */
    scale: DateTime_TimeSpanScale; // the scale of the timespan [default = DAYS]    /**
     * @generated from protobuf field: bcl.DateTime.DateTimeKind kind = 3;
     */
    kind: DateTime_DateTimeKind; // the kind of date/time being represented [default = UNSPECIFIED]}
/**
 * @generated from protobuf enum bcl.DateTime.TimeSpanScale
 */
export enum DateTime_TimeSpanScale {
    /**
     * @generated from protobuf enum value: DAYS = 0;
     */
    DAYS = 0,
    /**
     * @generated from protobuf enum value: HOURS = 1;
     */
    HOURS = 1,
    /**
     * @generated from protobuf enum value: MINUTES = 2;
     */
    MINUTES = 2,
    /**
     * @generated from protobuf enum value: SECONDS = 3;
     */
    SECONDS = 3,
    /**
     * @generated from protobuf enum value: MILLISECONDS = 4;
     */
    MILLISECONDS = 4,
    /**
     * @generated from protobuf enum value: TICKS = 5;
     */
    TICKS = 5,
    /**
     * dubious
     *
     * @generated from protobuf enum value: MINMAX = 15;
     */
    MINMAX = 15
}
/**
 * @generated from protobuf enum bcl.DateTime.DateTimeKind
 */
export enum DateTime_DateTimeKind {
    /**
     * The time represented is not specified as either local time or Coordinated Universal Time (UTC).
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * The time represented is UTC.
     *
     * @generated from protobuf enum value: UTC = 1;
     */
    UTC = 1,
    /**
     * The time represented is local time.
     *
     * @generated from protobuf enum value: LOCAL = 2;
     */
    LOCAL = 2
}
/**
 * @generated from protobuf message bcl.NetObjectProxy
 */
export interface NetObjectProxy {
    /**
     * @generated from protobuf field: int32 existingObjectKey = 1;
     */
    existingObjectKey: number; // for a tracked object, the key of the **first** time this object was seen    /**
     * @generated from protobuf field: int32 newObjectKey = 2;
     */
    newObjectKey: number; // for a tracked object, a **new** key, the first time this object is seen    /**
     * @generated from protobuf field: int32 existingTypeKey = 3;
     */
    existingTypeKey: number; // for dynamic typing, the key of the **first** time this type was seen    /**
     * @generated from protobuf field: int32 newTypeKey = 4;
     */
    newTypeKey: number; // for dynamic typing, a **new** key, the first time this type is seen    /**
     * @generated from protobuf field: string typeName = 8;
     */
    typeName: string; // for dynamic typing, the name of the type (only present along with newTypeKey)    /**
     * @generated from protobuf field: bytes payload = 10;
     */
    payload: Uint8Array; // the new string/value (only present along with newObjectKey)}
/**
 * @generated from protobuf message bcl.Guid
 */
export interface Guid {
    /**
     * @generated from protobuf field: fixed64 lo = 1;
     */
    lo: bigint; // the first 8 bytes of the guid (note:crazy-endian)    /**
     * @generated from protobuf field: fixed64 hi = 2;
     */
    hi: bigint; // the second 8 bytes of the guid (note:crazy-endian)}
/**
 * @generated from protobuf message bcl.Decimal
 */
export interface Decimal {
    /**
     * @generated from protobuf field: uint64 lo = 1;
     */
    lo: bigint; // the first 64 bits of the underlying value    /**
     * @generated from protobuf field: uint32 hi = 2;
     */
    hi: number; // the last 32 bis of the underlying value    /**
     * @generated from protobuf field: uint32 signScale = 3;
     */
    signScale: number; // the number of decimal digits (bits 1-16), and the sign (bit 0)}
// @generated message type with reflection information, may provide speed optimized methods
class TimeSpan$Type extends MessageType<TimeSpan> {
    constructor() {
        super("bcl.TimeSpan", [
            { no: 1, name: "value", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "scale", kind: "enum", T: () => ["bcl.TimeSpan.TimeSpanScale", TimeSpan_TimeSpanScale] }
        ]);
    }
    create(value?: PartialMessage<TimeSpan>): TimeSpan {
        const message = { value: 0n, scale: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeSpan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeSpan): TimeSpan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 value */ 1:
                    message.value = reader.sint64().toBigInt();
                    break;
                case /* bcl.TimeSpan.TimeSpanScale scale */ 2:
                    message.scale = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeSpan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.value);
        /* bcl.TimeSpan.TimeSpanScale scale = 2; */
        if (message.scale !== 0)
            writer.tag(2, WireType.Varint).int32(message.scale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bcl.TimeSpan
 */
export const TimeSpan = new TimeSpan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DateTime$Type extends MessageType<DateTime> {
    constructor() {
        super("bcl.DateTime", [
            { no: 1, name: "value", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "scale", kind: "enum", T: () => ["bcl.DateTime.TimeSpanScale", DateTime_TimeSpanScale] },
            { no: 3, name: "kind", kind: "enum", T: () => ["bcl.DateTime.DateTimeKind", DateTime_DateTimeKind] }
        ]);
    }
    create(value?: PartialMessage<DateTime>): DateTime {
        const message = { value: 0n, scale: 0, kind: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DateTime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DateTime): DateTime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 value */ 1:
                    message.value = reader.sint64().toBigInt();
                    break;
                case /* bcl.DateTime.TimeSpanScale scale */ 2:
                    message.scale = reader.int32();
                    break;
                case /* bcl.DateTime.DateTimeKind kind */ 3:
                    message.kind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DateTime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.value);
        /* bcl.DateTime.TimeSpanScale scale = 2; */
        if (message.scale !== 0)
            writer.tag(2, WireType.Varint).int32(message.scale);
        /* bcl.DateTime.DateTimeKind kind = 3; */
        if (message.kind !== 0)
            writer.tag(3, WireType.Varint).int32(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bcl.DateTime
 */
export const DateTime = new DateTime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetObjectProxy$Type extends MessageType<NetObjectProxy> {
    constructor() {
        super("bcl.NetObjectProxy", [
            { no: 1, name: "existingObjectKey", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "newObjectKey", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "existingTypeKey", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "newTypeKey", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "typeName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<NetObjectProxy>): NetObjectProxy {
        const message = { existingObjectKey: 0, newObjectKey: 0, existingTypeKey: 0, newTypeKey: 0, typeName: "", payload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NetObjectProxy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetObjectProxy): NetObjectProxy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 existingObjectKey */ 1:
                    message.existingObjectKey = reader.int32();
                    break;
                case /* int32 newObjectKey */ 2:
                    message.newObjectKey = reader.int32();
                    break;
                case /* int32 existingTypeKey */ 3:
                    message.existingTypeKey = reader.int32();
                    break;
                case /* int32 newTypeKey */ 4:
                    message.newTypeKey = reader.int32();
                    break;
                case /* string typeName */ 8:
                    message.typeName = reader.string();
                    break;
                case /* bytes payload */ 10:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetObjectProxy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 existingObjectKey = 1; */
        if (message.existingObjectKey !== 0)
            writer.tag(1, WireType.Varint).int32(message.existingObjectKey);
        /* int32 newObjectKey = 2; */
        if (message.newObjectKey !== 0)
            writer.tag(2, WireType.Varint).int32(message.newObjectKey);
        /* int32 existingTypeKey = 3; */
        if (message.existingTypeKey !== 0)
            writer.tag(3, WireType.Varint).int32(message.existingTypeKey);
        /* int32 newTypeKey = 4; */
        if (message.newTypeKey !== 0)
            writer.tag(4, WireType.Varint).int32(message.newTypeKey);
        /* string typeName = 8; */
        if (message.typeName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.typeName);
        /* bytes payload = 10; */
        if (message.payload.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bcl.NetObjectProxy
 */
export const NetObjectProxy = new NetObjectProxy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Guid$Type extends MessageType<Guid> {
    constructor() {
        super("bcl.Guid", [
            { no: 1, name: "lo", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "hi", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Guid>): Guid {
        const message = { lo: 0n, hi: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Guid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Guid): Guid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 lo */ 1:
                    message.lo = reader.fixed64().toBigInt();
                    break;
                case /* fixed64 hi */ 2:
                    message.hi = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Guid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 lo = 1; */
        if (message.lo !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.lo);
        /* fixed64 hi = 2; */
        if (message.hi !== 0n)
            writer.tag(2, WireType.Bit64).fixed64(message.hi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bcl.Guid
 */
export const Guid = new Guid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decimal$Type extends MessageType<Decimal> {
    constructor() {
        super("bcl.Decimal", [
            { no: 1, name: "lo", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "hi", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "signScale", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Decimal>): Decimal {
        const message = { lo: 0n, hi: 0, signScale: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Decimal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decimal): Decimal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 lo */ 1:
                    message.lo = reader.uint64().toBigInt();
                    break;
                case /* uint32 hi */ 2:
                    message.hi = reader.uint32();
                    break;
                case /* uint32 signScale */ 3:
                    message.signScale = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decimal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 lo = 1; */
        if (message.lo !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.lo);
        /* uint32 hi = 2; */
        if (message.hi !== 0)
            writer.tag(2, WireType.Varint).uint32(message.hi);
        /* uint32 signScale = 3; */
        if (message.signScale !== 0)
            writer.tag(3, WireType.Varint).uint32(message.signScale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bcl.Decimal
 */
export const Decimal = new Decimal$Type();
