// The types in here indicate how protobuf-net represents certain types when using protobuf-net specific
// library features. Note that it is not *required* to use any of these types, and cross-platform code
// should usually avoid them completely (ideally starting from a .proto schema)

// Some of these are ugly, sorry. The TimeSpan / DateTime dates here pre-date the introduction of Timestamp
// and Duration, and the "well known" types should be preferred when possible. Guids are particularly
// awkward - it turns out that there are multiple guid representations, and I accidentally used one that
// I can only call... "crazy-endian". Just make sure you check the order!

// It should not be necessary to use bcl.proto from code that uses protobuf-net

// @generated by protoc-gen-es v1.1.1 with parameter "target=ts"
// @generated from file protobuf-net/bcl.proto (package bcl, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message bcl.TimeSpan
 */
export class TimeSpan extends Message<TimeSpan> {
  /**
   * the size of the timespan (in units of the selected scale)
   *
   * @generated from field: sint64 value = 1;
   */
  value = protoInt64.zero;

  /**
   * the scale of the timespan [default = DAYS]
   *
   * @generated from field: bcl.TimeSpan.TimeSpanScale scale = 2;
   */
  scale = TimeSpan_TimeSpanScale.DAYS;

  constructor(data?: PartialMessage<TimeSpan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bcl.TimeSpan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
    { no: 2, name: "scale", kind: "enum", T: proto3.getEnumType(TimeSpan_TimeSpanScale) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSpan {
    return new TimeSpan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSpan {
    return new TimeSpan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSpan {
    return new TimeSpan().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSpan | PlainMessage<TimeSpan> | undefined, b: TimeSpan | PlainMessage<TimeSpan> | undefined): boolean {
    return proto3.util.equals(TimeSpan, a, b);
  }
}

/**
 * @generated from enum bcl.TimeSpan.TimeSpanScale
 */
export enum TimeSpan_TimeSpanScale {
  /**
   * @generated from enum value: DAYS = 0;
   */
  DAYS = 0,

  /**
   * @generated from enum value: HOURS = 1;
   */
  HOURS = 1,

  /**
   * @generated from enum value: MINUTES = 2;
   */
  MINUTES = 2,

  /**
   * @generated from enum value: SECONDS = 3;
   */
  SECONDS = 3,

  /**
   * @generated from enum value: MILLISECONDS = 4;
   */
  MILLISECONDS = 4,

  /**
   * @generated from enum value: TICKS = 5;
   */
  TICKS = 5,

  /**
   * dubious
   *
   * @generated from enum value: MINMAX = 15;
   */
  MINMAX = 15,
}
// Retrieve enum metadata with: proto3.getEnumType(TimeSpan_TimeSpanScale)
proto3.util.setEnumType(TimeSpan_TimeSpanScale, "bcl.TimeSpan.TimeSpanScale", [
  { no: 0, name: "DAYS" },
  { no: 1, name: "HOURS" },
  { no: 2, name: "MINUTES" },
  { no: 3, name: "SECONDS" },
  { no: 4, name: "MILLISECONDS" },
  { no: 5, name: "TICKS" },
  { no: 15, name: "MINMAX" },
]);

/**
 * @generated from message bcl.DateTime
 */
export class DateTime extends Message<DateTime> {
  /**
   * the offset (in units of the selected scale) from 1970/01/01
   *
   * @generated from field: sint64 value = 1;
   */
  value = protoInt64.zero;

  /**
   * the scale of the timespan [default = DAYS]
   *
   * @generated from field: bcl.DateTime.TimeSpanScale scale = 2;
   */
  scale = DateTime_TimeSpanScale.DAYS;

  /**
   * the kind of date/time being represented [default = UNSPECIFIED]
   *
   * @generated from field: bcl.DateTime.DateTimeKind kind = 3;
   */
  kind = DateTime_DateTimeKind.UNSPECIFIED;

  constructor(data?: PartialMessage<DateTime>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bcl.DateTime";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 18 /* ScalarType.SINT64 */ },
    { no: 2, name: "scale", kind: "enum", T: proto3.getEnumType(DateTime_TimeSpanScale) },
    { no: 3, name: "kind", kind: "enum", T: proto3.getEnumType(DateTime_DateTimeKind) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DateTime {
    return new DateTime().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DateTime {
    return new DateTime().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DateTime {
    return new DateTime().fromJsonString(jsonString, options);
  }

  static equals(a: DateTime | PlainMessage<DateTime> | undefined, b: DateTime | PlainMessage<DateTime> | undefined): boolean {
    return proto3.util.equals(DateTime, a, b);
  }
}

/**
 * @generated from enum bcl.DateTime.TimeSpanScale
 */
export enum DateTime_TimeSpanScale {
  /**
   * @generated from enum value: DAYS = 0;
   */
  DAYS = 0,

  /**
   * @generated from enum value: HOURS = 1;
   */
  HOURS = 1,

  /**
   * @generated from enum value: MINUTES = 2;
   */
  MINUTES = 2,

  /**
   * @generated from enum value: SECONDS = 3;
   */
  SECONDS = 3,

  /**
   * @generated from enum value: MILLISECONDS = 4;
   */
  MILLISECONDS = 4,

  /**
   * @generated from enum value: TICKS = 5;
   */
  TICKS = 5,

  /**
   * dubious
   *
   * @generated from enum value: MINMAX = 15;
   */
  MINMAX = 15,
}
// Retrieve enum metadata with: proto3.getEnumType(DateTime_TimeSpanScale)
proto3.util.setEnumType(DateTime_TimeSpanScale, "bcl.DateTime.TimeSpanScale", [
  { no: 0, name: "DAYS" },
  { no: 1, name: "HOURS" },
  { no: 2, name: "MINUTES" },
  { no: 3, name: "SECONDS" },
  { no: 4, name: "MILLISECONDS" },
  { no: 5, name: "TICKS" },
  { no: 15, name: "MINMAX" },
]);

/**
 * @generated from enum bcl.DateTime.DateTimeKind
 */
export enum DateTime_DateTimeKind {
  /**
   * The time represented is not specified as either local time or Coordinated Universal Time (UTC).
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The time represented is UTC.
   *
   * @generated from enum value: UTC = 1;
   */
  UTC = 1,

  /**
   * The time represented is local time.
   *
   * @generated from enum value: LOCAL = 2;
   */
  LOCAL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DateTime_DateTimeKind)
proto3.util.setEnumType(DateTime_DateTimeKind, "bcl.DateTime.DateTimeKind", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "UTC" },
  { no: 2, name: "LOCAL" },
]);

/**
 * @generated from message bcl.NetObjectProxy
 */
export class NetObjectProxy extends Message<NetObjectProxy> {
  /**
   * for a tracked object, the key of the **first** time this object was seen
   *
   * @generated from field: int32 existingObjectKey = 1;
   */
  existingObjectKey = 0;

  /**
   * for a tracked object, a **new** key, the first time this object is seen
   *
   * @generated from field: int32 newObjectKey = 2;
   */
  newObjectKey = 0;

  /**
   * for dynamic typing, the key of the **first** time this type was seen
   *
   * @generated from field: int32 existingTypeKey = 3;
   */
  existingTypeKey = 0;

  /**
   * for dynamic typing, a **new** key, the first time this type is seen
   *
   * @generated from field: int32 newTypeKey = 4;
   */
  newTypeKey = 0;

  /**
   * for dynamic typing, the name of the type (only present along with newTypeKey)
   *
   * @generated from field: string typeName = 8;
   */
  typeName = "";

  /**
   * the new string/value (only present along with newObjectKey)
   *
   * @generated from field: bytes payload = 10;
   */
  payload = new Uint8Array(0);

  constructor(data?: PartialMessage<NetObjectProxy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bcl.NetObjectProxy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "existingObjectKey", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "newObjectKey", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "existingTypeKey", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "newTypeKey", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "typeName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetObjectProxy {
    return new NetObjectProxy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetObjectProxy {
    return new NetObjectProxy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetObjectProxy {
    return new NetObjectProxy().fromJsonString(jsonString, options);
  }

  static equals(a: NetObjectProxy | PlainMessage<NetObjectProxy> | undefined, b: NetObjectProxy | PlainMessage<NetObjectProxy> | undefined): boolean {
    return proto3.util.equals(NetObjectProxy, a, b);
  }
}

/**
 * @generated from message bcl.Guid
 */
export class Guid extends Message<Guid> {
  /**
   * the first 8 bytes of the guid (note:crazy-endian)
   *
   * @generated from field: fixed64 lo = 1;
   */
  lo = protoInt64.zero;

  /**
   * the second 8 bytes of the guid (note:crazy-endian)
   *
   * @generated from field: fixed64 hi = 2;
   */
  hi = protoInt64.zero;

  constructor(data?: PartialMessage<Guid>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bcl.Guid";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lo", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 2, name: "hi", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Guid {
    return new Guid().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Guid {
    return new Guid().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Guid {
    return new Guid().fromJsonString(jsonString, options);
  }

  static equals(a: Guid | PlainMessage<Guid> | undefined, b: Guid | PlainMessage<Guid> | undefined): boolean {
    return proto3.util.equals(Guid, a, b);
  }
}

/**
 * @generated from message bcl.Decimal
 */
export class Decimal extends Message<Decimal> {
  /**
   * the first 64 bits of the underlying value
   *
   * @generated from field: uint64 lo = 1;
   */
  lo = protoInt64.zero;

  /**
   * the last 32 bis of the underlying value
   *
   * @generated from field: uint32 hi = 2;
   */
  hi = 0;

  /**
   * the number of decimal digits (bits 1-16), and the sign (bit 0)
   *
   * @generated from field: uint32 signScale = 3;
   */
  signScale = 0;

  constructor(data?: PartialMessage<Decimal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bcl.Decimal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lo", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "hi", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "signScale", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Decimal {
    return new Decimal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Decimal {
    return new Decimal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Decimal {
    return new Decimal().fromJsonString(jsonString, options);
  }

  static equals(a: Decimal | PlainMessage<Decimal> | undefined, b: Decimal | PlainMessage<Decimal> | undefined): boolean {
    return proto3.util.equals(Decimal, a, b);
  }
}

